#include "controlMethod.H"

//---------------------------------------------------------------------------*/

namespace Foam
{
namespace maneuvering
{
    defineTypeNameAndDebug(controlMethod, 0);
    defineRunTimeSelectionTable(controlMethod, dictionary);

    defineTypeNameAndDebug(turningControl, 0);
    addToRunTimeSelectionTable
    (
        controlMethod,
        turningControl,
        dictionary
    );

    defineTypeNameAndDebug(zigzagControl, 0);
    addToRunTimeSelectionTable
    (
        controlMethod,
        zigzagControl,
        dictionary
    );

    defineTypeNameAndDebug(sailingControl, 0);
    addToRunTimeSelectionTable
    (
        controlMethod,
        sailingControl,
        dictionary
    );

    defineTypeNameAndDebug(coursekeepingControl, 0);
    addToRunTimeSelectionTable
    (
        controlMethod,
        coursekeepingControl,
        dictionary
    );    
}
}

// * * * * * * * * * * * * base  * * * * * * * * * * * * //
Foam::maneuvering::controlMethod::controlMethod(const dictionary &dict)
: 
    controlType_(dict.get<word>("type")),
    cStartTime_(dict.getOrDefault<scalar>("controllerStartTime", 0.)),
    cEndTime_(dict.getOrDefault<scalar>("controllerEndTime", 10000.)),
    controlName_(dict.dictName())
{}

void Foam::maneuvering::controlMethod::write(Ostream &os) const
{
    os.writeEntry("maneuveringMode", controlType_);
}

void Foam::maneuvering::controlMethod::write(dictionary& dict) const
{
    dict.add("controllerStartTime", cStartTime_);
    dict.add("controllerEndTime", cEndTime_);
}

scalar Foam::maneuvering::controlMethod::cStartTime() const
{
    return cStartTime_;
}

scalar Foam::maneuvering::controlMethod::cEndTime() const
{
    return cEndTime_;
}

const word Foam::maneuvering::controlMethod::controlName() const
{
    return controlName_;
}

// * * * * * * * * * * * * turning Control  * * * * * * * * * * * * //
Foam::maneuvering::turningControl::turningControl(const dictionary &dict)
: 
    controlMethod(dict),
    cTarget_(dict.getOrDefault<scalar>("controllerYawAngle", 270.)),
    cMax_(dict.getOrDefault<scalar>("controllerRudder", 35.)),
    cRate_(dict.getOrDefault<scalar>("controllerRate", 5.)),
    outputSignal_(dict.getOrDefault<scalar>("outputSignal", 0.))
{}

scalar Foam::maneuvering::turningControl::calculate(scalar currentYaw, const scalar deltaT) const
{
    Info<<nl<<"turningControl is running!!"<<nl;

    if(fabs(outputSignal_) >= fabs(cMax_)*M_PI/180)
    {
       outputSignal_ = cMax_*M_PI/180;
       //return outputSignal_;
       return 0.0;
    }
    outputSignal_ += cRate_*deltaT*M_PI/180;
    //return outputSignal_;
    return cRate_*M_PI/180;
}

void Foam::maneuvering::turningControl::write(Ostream &os) const
{
    controlMethod::write(os);
    os.beginBlock("parameters");
    os.writeEntryIfDifferent("controllerTarget", 0.,  cTarget_);
    os.endBlock();
}

void Foam::maneuvering::turningControl::write(dictionary& dict) const
{
    controlMethod::write(dict);
    dict.add("controllerYawAngle", cTarget_);
    dict.add("controllerRudder", cMax_);
    dict.add("controllerRate", cRate_);
    dict.add("outputSignal", outputSignal_);
    
}

// * * * * * * * * * * * * zigzag Control  * * * * * * * * * * * * //
Foam::maneuvering::zigzagControl::zigzagControl(const dictionary &dict)
: 
    controlMethod(dict),
    cTarget_(dict.getOrDefault<scalar>("controllerYawAngle", 20.)),
    cMax_(dict.getOrDefault<scalar>("controllerRudder", 20.)),
    cRate_(dict.getOrDefault<scalar>("controllerRate", 5.)),
    outputSignal_(dict.getOrDefault<scalar>("outputSignal", 0.)),
    oldYaw_(dict.getOrDefault<scalar>("oldYaw", 0.))
{
 
}

scalar Foam::maneuvering::zigzagControl::calculate(scalar currentYaw, const scalar deltaT) const
{
    Info<<nl<<"zigzagControl is running!!"<<nl;
    if
    (oldYaw_ < fabs(cTarget_)*M_PI/180 && currentYaw >= fabs(cTarget_)*M_PI/180)
    {
       cRate_ = fabs(cRate_);
    }
       
    else if
    (oldYaw_ > -1*fabs(cTarget_)*M_PI/180 && currentYaw <= -1*fabs(cTarget_)*M_PI/180)
    {
       cRate_ = -1*fabs(cRate_);      
    } 
       
    outputSignal_ += cRate_*deltaT;

    Info<<"currentYaw = "<<currentYaw*180/M_PI<<nl
        <<"outputSignal_ = "<<outputSignal_<<endl;
    
    if(outputSignal_ >= fabs(cMax_))
    {
       outputSignal_ = fabs(cMax_);
       oldYaw_ = currentYaw;
       return 0.0;    
    }
    
    else if(outputSignal_ <= -1*fabs(cMax_))
    {
       outputSignal_ = -1*fabs(cMax_);
       oldYaw_ = currentYaw;
       return 0.0;        
    }
          
    oldYaw_ = currentYaw;
    
    //return outputSignal_;
    return cRate_*M_PI/180;
}

void Foam::maneuvering::zigzagControl::write(Ostream &os) const
{
    controlMethod::write(os);
    os.beginBlock("parameters");
    os.writeEntryIfDifferent("controllerTarget", 0.,  cTarget_);
    os.endBlock();
}

void Foam::maneuvering::zigzagControl::write(dictionary& dict) const
{
    controlMethod::write(dict);
    dict.add("controllerYawAngle", cTarget_);
    dict.add("controllerRudder", cMax_);
    dict.add("controllerRate", cRate_);
    dict.add("outputSignal", outputSignal_);
    dict.add("oldYaw", oldYaw_);
    
}

// * * * * * * * * * * * * sailing Control  * * * * * * * * * * * * //
Foam::maneuvering::sailingControl::sailingControl(const dictionary &dict)
: 
    controlMethod(dict),
    P_(dict.getOrDefault<scalar>("controllerP", 1.)),
    I_(dict.getOrDefault<scalar>("controllerI", 1.)),
    D_(dict.getOrDefault<scalar>("controllerD", 0.)),
    cTarget_(dict.getOrDefault<scalar>("controllerTarget", 1.)),
    outputMax_(dict.getOrDefault<scalar>("controllerMax", 100.)),
    outputMin_(dict.getOrDefault<scalar>("controllerMin", 1.)),
    errorMax_(16.),
    integralErrorMax_(VGREAT),
    oldError_(dict.getOrDefault<scalar>("oldError", 0.)),
    errorIntegral_(dict.getOrDefault<scalar>("errorIntegral", 0.)),
    outputSignal_(dict.getOrDefault<scalar>("outputSignal", 0.))
{
    Info<<nl<<"********************************"<<nl
    <<"oldError: "<<oldError_<<nl
    <<"errorIntegral: "<<errorIntegral_<<nl
    <<"outputSignal: "<<outputSignal_<<endl;
}

scalar Foam::maneuvering::sailingControl::calculate(scalar currentV, scalar deltaT) const
{
    Info<<nl<<"sailingControl is running!!"<<nl;
    Info<<nl<<"errorIntegral: "<<errorIntegral_<<endl;
    scalar error = fabs(cTarget_) - fabs(currentV);
    error = max(min(error, errorMax_), -errorMax_);  // Constain error according to specified errorMax
    errorIntegral_ += error * deltaT;
    errorIntegral_ = max(min(errorIntegral_, integralErrorMax_), -integralErrorMax_);
    const scalar errorDifferential = (error - oldError_);
    oldError_ = error;

    // Calculate increased output RPS value

    const scalar increasedOutputSignal = P_*180/M_PI*error + I_*errorIntegral_ + D_*errorDifferential;
    outputSignal_ = increasedOutputSignal;
    
    // Return result within defined regulator saturation: outputMax_ and outputMin_
    return max(min(outputSignal_, outputMax_), outputMin_);
}

void Foam::maneuvering::sailingControl::write(Ostream &os) const
{
    controlMethod::write(os);
    os.beginBlock("parameters");
    os.writeEntry("Kp", P_);
    os.writeEntry("Ti", I_);
    os.writeEntry("Td", D_);
    os.writeEntryIfDifferent("outputMax", 1., outputMax_);
    os.writeEntryIfDifferent("outputMin", 0., outputMin_);
    os.writeEntryIfDifferent("errMax", VGREAT, errorMax_);
    os.writeEntryIfDifferent("errIntegMax", VGREAT, integralErrorMax_);
    os.endBlock();
}

void Foam::maneuvering::sailingControl::write(dictionary& dict) const
{
    controlMethod::write(dict);
    dict.add("controllerP", P_);
    dict.add("controllerI", I_);
    dict.add("controllerD", D_);
    dict.add("controllerTarget", cTarget_);
    dict.add("controllerMax", outputMax_);
    dict.add("controllerMin", outputMin_);
    dict.add("oldError", oldError_);
    dict.add("errorIntegral", errorIntegral_);
    dict.add("outputSignal", outputSignal_);
}

// * * * * * * * * * * * * coursekeeping Control  * * * * * * * * * * * * //
Foam::maneuvering::coursekeepingControl::coursekeepingControl(const dictionary &dict)
: 
    controlMethod(dict),
    P_(dict.getOrDefault<scalar>("controllerP", 1.)),
    I_(dict.getOrDefault<scalar>("controllerI", 0.)),
    D_(dict.getOrDefault<scalar>("controllerD", 1.)),
    cTarget_(dict.getOrDefault<scalar>("controllerTarget", 0.)),
    maxRate_(dict.getOrDefault<scalar>("maxRuuderRate", 35.)),   //Maximum rudder rate in deg
    maxAngle_(dict.getOrDefault<scalar>("maxRudderAngle", 35.)), //Maximum ruuder angle in deg
    errorIntegral_(dict.getOrDefault<scalar>("errorIntegral", 0.)), 
    oldError_(dict.getOrDefault<scalar>("oldError", 0.)),
    oldRudderRate_(dict.getOrDefault<scalar>("oldRudderRate", 0.)),
    oldRudderAngle_(dict.getOrDefault<scalar>("oldRudderAngle", 0.))

{}

scalar Foam::maneuvering::coursekeepingControl::calculate(scalar currentYaw, scalar deltaT) const
{
    Info<<nl<<"coursekeepingControl is running!!"<<nl;
    scalar error = currentYaw - cTarget_*M_PI/180;
    //scalar error = cTarget_*M_PI/180 - currentYaw;
    // error = max(min(error, errorMax_), -errorMax_);  // Constain error according to specified errorMax
    errorIntegral_ += error * deltaT;
    // errorIntegral_ = max(min(errorIntegral_, integralErrorMax_), -integralErrorMax_);
    scalar errorDifferential = (error - oldError_)/deltaT;
    oldError_ = error;

    // Calculate output rudder rate

    scalar presentRudderAngle = P_*error + I_*errorIntegral_ + D_*errorDifferential;
    if(fabs(presentRudderAngle) > fabs(maxAngle_)*M_PI/180)
    {
        presentRudderAngle = presentRudderAngle/fabs(presentRudderAngle)*fabs(maxAngle_)*M_PI/180;
    }

    scalar presentRudderRate  = (presentRudderAngle -oldRudderAngle_)*2.0/deltaT - oldRudderRate_;
    if(fabs(presentRudderRate) > fabs(maxRate_)*M_PI/180)
    {
        presentRudderRate = presentRudderRate/fabs(presentRudderRate)*fabs(maxRate_)*M_PI/180;
    }
    
    presentRudderAngle = oldRudderAngle_ + (oldRudderRate_ + presentRudderRate)*deltaT/2.0;

    oldRudderAngle_ = presentRudderAngle;
    oldRudderRate_  = presentRudderRate;
    
    return presentRudderRate;
}

void Foam::maneuvering::coursekeepingControl::write(Ostream &os) const
{
    controlMethod::write(os);
    os.beginBlock("parameters");
    os.writeEntry("Kp", P_);
    os.writeEntry("Ti", I_);
    os.writeEntry("Td", D_);
    // os.writeEntryIfDifferent("outputMax", 1., outputMax_);
    // os.writeEntryIfDifferent("outputMin", 0., outputMin_);
    // os.writeEntryIfDifferent("errMax", VGREAT, errorMax_);
    // os.writeEntryIfDifferent("errIntegMax", VGREAT, integralErrorMax_);
    os.endBlock();
}

void Foam::maneuvering::coursekeepingControl::write(dictionary& dict) const
{
    controlMethod::write(dict);
    dict.add("controllerP", P_);
    dict.add("controllerI", I_);
    dict.add("controllerD", D_);
    dict.add("controllerTarget", cTarget_);    //in deg
    dict.add("maxRuuderRate", maxRate_);      //in deg
    dict.add("maxRudderAngle", maxAngle_);   //in deg
    dict.add("errorIntegral", errorIntegral_);
    dict.add("oldError", oldError_);
    dict.add("oldRudderRate", oldRudderRate_);
    dict.add("oldRudderAngle", oldRudderAngle_);

}

